import json
from web3 import Web3
from hexbytes import HexBytes
from collections import deque

NULL_PRINCIPAL = "0x0000000000000000000000000000000000000000"
NULL_ROLENAME = "0x0000"
MAX_WEIGHT = 100

# First commit

"""
------------------------------------------------------------------------------------
EXPRESSIONS
------------------------------------------------------------------------------------
"""

class Expression:
    """
    Interface for a generic expression.
    
    Each expression must be initialized with an identifier,
    based on which the equality operator between expressions is defined.
    The generation of this identifier varies depending on the type of expression
    and corresponds to the same method used by the on-chain contract.
    """

    def __init__(self, id):
        self.id = id

    def __hash__(self):
        return Web3.to_int(self.id)

    def __eq__(self, other):
        return self.id == other.id


class SMExpression(Expression):
    """
    Data record representing a role expression for a Simple Member credential.
    """

    def __init__(self, member):
        b = bytes(HexBytes(member))
        # The identifier of a simple member is the address of the member itself
        # followed by a sequence of zeros
        super().__init__(HexBytes(b.ljust(32, b'\x00')))
        self.member = member

    def __iter__(self):
        yield from [self.member]


class SIExpression(Expression):
    """
    Data record representing a role expression for a Simple Inclusion credential
    or an assigned role of any credential.
    """
    
    def __init__(self, principal, roleName):
        # The identifier of a simple inclusion is generated by applying the hashing function to its data
        super().__init__(Web3.solidity_keccak(['address', 'bytes2', 'address', 'bytes2'], [principal, roleName, NULL_PRINCIPAL, NULL_ROLENAME]))
        self.principal = principal
        self.roleName = roleName

    def __iter__(self):
        yield from [self.principal, self.roleName]


class LIExpression(Expression):
    """
    Data record representing a role expression for a Linked Inclusion credential.
    """

    def __init__(self, principal, roleNameA, roleNameB):
        # The identifier of a linked inclusion is generated by applying the hashing function to its data
        super().__init__(Web3.solidity_keccak(['address', 'bytes2', 'address', 'bytes2'], [principal, roleNameA, NULL_PRINCIPAL, roleNameB]))
        self.principal = principal
        self.roleNameA = roleNameA
        self.roleNameB = roleNameB

    def __iter__(self):
        yield from [self.principal, self.roleNameA, self.roleNameB]

class IIExpression(Expression):
    """
    Data record representing a role expression for an Intersection Inclusion credential.
    """

    def __init__(self, principalA, roleNameA, principalB, roleNameB):
        # The identifier of an intersection inclusion is generated by applying the hashing function to its data
        # which are first sorted to consider expressions P1.r1 ∩ P2.r2 and P2.r2 ∩ P1.r1 equivalent
        if ((HexBytes(principalB) > HexBytes(principalA)) or (HexBytes(principalA) == HexBytes(principalB) and HexBytes(roleNameB) > HexBytes(roleNameA))):
            principalA, roleNameA, principalB, roleNameB = principalB, roleNameB, principalA, roleNameA
        super().__init__(Web3.solidity_keccak(['address', 'bytes2', 'address', 'bytes2'], [principalA, roleNameA, principalB, roleNameB]))
        self.principalA = principalA
        self.roleNameA = roleNameA
        self.principalB = principalB
        self.roleNameB = roleNameB

    def __iter__(self):
        yield from [self.principalA, self.roleNameA, self.principalB, self.roleNameB]


"""
------------------------------------------------------------------------------------
SUPPORT ADT FOR SEARCH ALGORITHM
------------------------------------------------------------------------------------
"""

class Solution:
    """
    Data record representing a solution held by a ProofNode.

    member: the address of the principal object of the solution
    weight: the confidence value associated with the solution
    path: sequence of ProofEdge(s) traversed by the solution to reach the ProofNode holding the solution
    reqStackSize: size of the stack sufficient for the solution to be verified on-chain
    """

    def __init__(self, member, weight, path = [], reqStackSize = 1):
        self.member = member
        self.weight = weight
        self.path = path
        self.reqStackSize = reqStackSize


class Monitor:
    """
    Interface for a generic monitor of the backward search algorithm.

    Each monitor has:
    - destNode: the ProofNode to which the solutions will be sent
    - proofGraph: the ProofGraph in which to insert any new nodes or edges
    - dart: the instance of the on-chain dart contract on which the search is performed
    - notify(): method to notify the monitor of a new solution
    """

    def __init__(self, destNode, proofGraph, dart):
        self.destNode = destNode
        self.proofGraph = proofGraph
        self.dart = dart

    def notify(self, solution, fromNode):
        pass


class LinkingMonitor(Monitor):
    """
    Monitor to handle linked inclusions.

    A LinkingMonitor to handle Linked Inclusion credentials A.a <- P.r1.r2:
    - has the ProofNode representing the expression A.a as the destination node destNode
    - is notified upon receiving new solutions from the ProofNode representing the expression P.r1
    """

    def __init__(self, destNode, proofGraph, dart):
        super().__init__(destNode, proofGraph, dart)

    def notify(self, solution, fromNode=None):
        # Notification of receiving a new solution solution from P.r1
        # Add, if not present, a new node representing the expression (solution.member).r2
        # and an edge between it and P.r1.r2 weighted with the same confidence value as solution

        linkedRole = SIExpression(solution.member, self.destNode.expr.roleNameB)
        if self.dart.exprExists(linkedRole):
            self.proofGraph.addNode(linkedRole)
            self.proofGraph.addEdge(linkedRole, self.destNode.expr, solution.weight, solution)

class IntersectionMonitor(Monitor):
    """
    Monitor to handle intersection inclusions.

    An IntersectionMonitor to handle Intersection Inclusion credentials A.a <- P1.r1 ∩ P2.r2:
    - has the ProofNode representing the expression A.a as the destination node destNode
    - is notified upon receiving new solutions from the ProofNodes representing the expressions P1.r1 and P2.r2
    """

    def __init__(self, destNode, proofGraph, dart):
        super().__init__(destNode, proofGraph, dart)
        self.solutionsA = {}
        self.solutionsB = {}
        self.roleA = SIExpression(destNode.expr.principalA, destNode.expr.roleNameA)
        self.roleB = SIExpression(destNode.expr.principalB, destNode.expr.roleNameB)
    
    def notify(self, solution, fromNode):
        # Notification of receiving a new solution solution from one of the two nodes P1.r1 or P2.r2.
        # Add the solution to the corresponding set of solutions if new or with a greater confidence value.
        # If two solutions with the same member object are present in both sets,
        # send a new solution to destNode composed of:
        # - the member in question
        # - the minimum confidence value between the two solutions
        # - as a path, a concatenation of the paths of the two solutions, placing the shorter one first
        # - a reqStackSize sufficient to on-chain verify the sequence of credentials represented by the aforementioned path concatenation

        if fromNode.expr == self.roleA:
            solutions = self.solutionsA
            otherSolutions = self.solutionsB
        elif fromNode.expr == self.roleB:
            solutions = self.solutionsB
            otherSolutions = self.solutionsA
        else:
            return

        if solution.member not in solutions or solutions[solution.member].weight < solution.weight:
            solutions[solution.member] = solution
            if solution.member in otherSolutions:
                
                otherSolution = otherSolutions[solution.member]
                outputWeight = min(solution.weight, otherSolution.weight)

                if solution.reqStackSize > otherSolution.reqStackSize:
                    outputPath = solution.path + otherSolution.path
                    outputReqStackSize = solution.reqStackSize
                elif solution.reqStackSize < otherSolution.reqStackSize:
                    outputPath = otherSolution.path + solution.path
                    outputReqStackSize = otherSolution.reqStackSize
                else:
                    outputPath = solution.path + otherSolution.path
                    outputReqStackSize = solution.reqStackSize + 1

                intersectedSolution = Solution(solution.member, outputWeight, outputPath, outputReqStackSize)
                self.destNode.addSolution(intersectedSolution)


class ProofEdge:
    """
    ADT representing a directed edge of the ProofGraph.

    fromNode: the source ProofNode
    toNode: the destination ProofNode
    weight: the weight associated with the edge
    supportSolution: any solution that justified the generation of the edge
    """

    def __init__(self, fromNode, toNode, weight, supportSolution=None):
        self.fromNode = fromNode
        self.toNode = toNode
        self.weight = weight
        self.supportSolution = supportSolution

    def sendSolution(self, solution):
        # Transmit a solution through the edge:
        # the solution is first signed with the signSolution() method
        # then added to the solutions of the destination node
        self.toNode.addSolution(self.signSolution(solution))

    def signSolution(self, solution):
        # Sign a solution that traverses the edge. Once signed, the following statements hold:
        # - the confidence value of the solution has been influenced by the weight of the edge
        # - the edge itself has been added to the solution's path
        # - if the edge has a supportSolution, the path of the supportSolution has also been added to the path
        # - reqStackSize has been updated and made sufficient to on-chain verify the sequence of credentials represented by the aforementioned path
        newWeight = (solution.weight * self.weight) / MAX_WEIGHT
        if self.supportSolution is None:
            newPath = solution.path + [self]
            newReqStackSize = solution.reqStackSize
        else:
            newPath = solution.path + [self] + self.supportSolution.path
            if solution.reqStackSize > self.supportSolution.reqStackSize:
                newReqStackSize = solution.reqStackSize
            else:
                newReqStackSize = self.supportSolution.reqStackSize + 1
        
        return Solution(solution.member, newWeight, newPath, newReqStackSize)


class ProofNode:
    """
    ADT representing a node of the ProofGraph.

    expr: the (SM/SI/LI/II)Expression represented by the node
    outEdges: set of outgoing edges
    solutions: set of solutions possessed by the node
    solutionsState: value corresponding to a specific state of solutions, incremented with each change in solutions
    monitors: set of monitors to notify upon inserting a new solution into solutions
    """

    def __init__(self, expr):
        self.expr = expr
        self.outEdges = {}
        self.solutions = {}
        self.solutionsState = 0
        self.monitors = []

    def addSolution(self, solution):
        # Request the insertion of solution among the solutions of the node.
        # The solution is accepted only if it is a new member or has a greater confidence value.
        # If accepted:
        # - the solutionsState counter is updated
        # - the solution is transmitted through all outgoing edges
        # - all monitors are notified of the new solution
        if solution.member not in self.solutions or self.solutions[solution.member].weight < solution.weight:
            self.solutions[solution.member] = solution
            self.solutionsState += 1
            for monitor in self.monitors:
                monitor.notify(solution, self)
            for edge in self.outEdges.values():
                edge.sendSolution(solution)

    def attachMonitor(self, monitor):
        # Attach a new monitor to the node.
        # If the node has solutions, notify all of them to the new monitor.
        # This operation could lead to the reception of new solutions,
        # so it is necessary to operate on a copy of the set of solutions
        self.monitors.append(monitor)
        if len(self.solutions) != 0:
            while True:
                currSolutionsState = self.solutionsState
                solutionsList = list(self.solutions.values())
                for solution in solutionsList:
                    monitor.notify(solution, self)
                if currSolutionsState == self.solutionsState:
                    break

class ProofGraph:
    """
    ADT representing a graph generated by the backward search algorithm.

    nodes: set of ProofGraph nodes the graph is composed of
    queue: queue of ProofNode(s) used by the backward search algorithm to generate the graph
    """

    def __init__(self):
        self.nodes = {}
        self.queue = deque()

    def addNode(self, expr):
        # Request the insertion of a new node into the graph.
        # The node is accepted only if it represents a new expression.
        # After acceptance, it is enqueued in the processing queue of the backward search algorithm
        if expr not in self.nodes:
            newNode = ProofNode(expr)
            self.nodes[expr] = newNode
            self.queue.append(newNode)
            return newNode
        else:
            return self.nodes[expr]

    def addEdge(self, fromExpr, toExpr, weight, supportSolution=None):
        # Request the insertion of a new edge into the graph.
        # The edge is accepted only if it is not present or if present with a lower confidence value.
        # Inserting a new edge involves transferring any solutions
        # from the source node to the destination node.
        # This operation could lead to the reception of new solutions from the source node,
        # so it is necessary to operate on a copy of the set of solutions
        if fromExpr in self.nodes and toExpr in self.nodes:
            fromNode = self.nodes[fromExpr]
            toNode = self.nodes[toExpr]
            newEdge = ProofEdge(fromNode, toNode, weight, supportSolution)
            if toNode not in fromNode.outEdges or fromNode.outEdges[toNode].weight < weight:
                fromNode.outEdges[toNode] = newEdge
                while True:
                    currSolutionsState = fromNode.solutionsState
                    solutionsList = list(fromNode.solutions.values())
                    for solution in solutionsList:
                        newEdge.sendSolution(solution)
                    if currSolutionsState == fromNode.solutionsState:
                        break


"""
------------------------------------------------------------------------------------
DART
------------------------------------------------------------------------------------
"""

class DART:
    """
    Class for interfacing with the on-chain DART contract.
    """

    def __init__(self, contractABI, contractAddress, w3):
        """
        Creates a new instance for interfacing with an on-chain DART contract.

        :param buildArtifactPath: path to the json artifact produced by compiling the DART contract using the truffle suite
        :param contractABI: array representing the ABI of the DART contract
        :param w3: Web3 instance connected to a blockchain node where the DART contract is deployed at the provided address
        """
        self.contract = w3.eth.contract(abi=contractABI, address=contractAddress)
        self.w3 = w3

    def newRole(self, roleName, tx={}):
        """
        Requests the creation of a new role
        
        :param roleName: string representing a valid hexadecimal value (e.g., 0xabcd) identifying the new role
        :param tx: optional parameter containing any transaction preferences
        """
        self.contract.functions.newRole(roleName).call(tx)
        txHash = self.contract.functions.newRole(roleName).transact(tx)
        self.w3.eth.wait_for_transaction_receipt(txHash)

    def addSimpleMember(self, assignedRolename, expression, weight, tx={}):
        """
        Requests the insertion of a new Simple Member credential for its own role
        
        :param assignedRolename: the rolename of the assigned role of the credential
        :param expression: the role expression SMExpression of the credential
        :param weight: confidence value associated with the credential
        :param tx: optional parameter containing any transaction preferences
        """
        self.contract.functions.addSimpleMember(assignedRolename, *expression, weight).call(tx)
        txHash = self.contract.functions.addSimpleMember(assignedRolename, *expression, weight).transact(tx)
        self.w3.eth.wait_for_transaction_receipt(txHash)

    def addSimpleInclusion(self, assignedRolename, expression, weight, tx={}):
        """
        Requests the insertion of a new Simple Inclusion credential for its own role
        
        :param assignedRolename: the rolename of the assigned role of the credential
        :param expression: the role expression SIExpression of the credential
        :param weight: confidence value associated with the credential
        :param tx: optional parameter containing any transaction preferences
        """
        self.contract.functions.addSimpleInclusion(assignedRolename, *expression, weight).call(tx)
        txHash = self.contract.functions.addSimpleInclusion(assignedRolename, *expression, weight).transact(tx)
        self.w3.eth.wait_for_transaction_receipt(txHash)

    def addLinkedInclusion(self, assignedRolename, expression, weight, tx={}):
        """
        Requests the insertion of a new Linked Inclusion credential for its own role
        
        :param assignedRolename: the rolename of the assigned role of the credential
        :param expression: the role expression LIExpression of the credential
        :param weight: confidence value associated with the credential
        :param tx: optional parameter containing any transaction preferences
        """
        self.contract.functions.addLinkedInclusion(assignedRolename, *expression, weight).call(tx)
        txHash = self.contract.functions.addLinkedInclusion(assignedRolename, *expression, weight).transact(tx)
        self.w3.eth.wait_for_transaction_receipt(txHash)

    def addIntersectionInclusion(self, assignedRolename, expression, weight, tx={}):
        """
        Requests the insertion of a new Intersection Inclusion credential for its own role
        
        :param assignedRolename: the rolename of the assigned role of the credential
        :param expression: the role expression IIExpression of the credential
        :param weight: confidence value associated with the credential
        :param tx: optional parameter containing any transaction preferences
        """
        self.contract.functions.addIntersectionInclusion(assignedRolename, *expression, weight).call(tx)
        txHash = self.contract.functions.addIntersectionInclusion(assignedRolename, *expression, weight).transact(tx)
        self.w3.eth.wait_for_transaction_receipt(txHash)

    # --------------------------------------------------------------------------------
    # TODO: operations for removing credentials and updating confidence values
    # --------------------------------------------------------------------------------

    def exprExists(self, expr):
        """        
        Returns True if the expr:Expression provided is part of at least one credential
        registered on the on-chain contract by any principal
        """
        return self.contract.functions.exprExists(expr.id).call()

    def getMembersCount(self, role):
        """
        Returns the number of Simple Member credentials having role:SIExpression as the assigned role
        """
        return self.contract.functions.getMembersCount(role.id).call()

    def getMember(self, role, memberIndex):
        """
        Returns the memberIndex-th member associated via Simple Member credential with role:SIExpression
        """
        (address, weight) = self.contract.functions.getMember(role.id, memberIndex).call()
        return (SMExpression(address), weight)

    def getInclusionsCount(self, role):
        """
        Returns the number of inclusion credentials (simple, linked, intersection)
        having role:SIExpression as the assigned role
        """
        return self.contract.functions.getInclusionsCount(role.id).call()

    def getInclusion(self, role, inclusionIndex):
        """
        Returns the inclusionIndex-th inclusion credential having role:SIExpression as the assigned role
        """
        (addrA, addrB, roleA, roleB, weight) = self.contract.functions.getInclusion(role.id, inclusionIndex).call()
        roleA = Web3.to_hex(roleA)
        roleB = Web3.to_hex(roleB)
        if addrB != NULL_PRINCIPAL:
            return (IIExpression(addrA, roleA, addrB, roleB), weight)
        elif roleB != NULL_ROLENAME:
            return (LIExpression(addrA, roleA, roleB), weight)
        else:
            return (SIExpression(addrA, roleA), weight)

    def search(self, role):
        """
        Executes the backward search algorithm starting from the provided role:SMExpression,
        returning the set of solutions found for that role
        """
        proofGraph = ProofGraph()
        startingNode = proofGraph.addNode(role)
        
        while len(proofGraph.queue) != 0:
            currNode = proofGraph.queue.popleft()

            if isinstance(currNode.expr, SMExpression):
                currNode.addSolution(Solution(currNode.expr.member, MAX_WEIGHT))

            elif isinstance(currNode.expr, SIExpression):
                nMembers = self.getMembersCount(currNode.expr)
                for i in range(0, nMembers):
                    (memberExpr, credWeight) = self.getMember(currNode.expr, i)
                    proofGraph.addNode(memberExpr)
                    proofGraph.addEdge(memberExpr, currNode.expr, credWeight)
                nInclusions = self.getInclusionsCount(currNode.expr)
                for i in range(0, nInclusions):
                    (inclExpr, credWeight) = self.getInclusion(currNode.expr, i)
                    proofGraph.addNode(inclExpr)
                    proofGraph.addEdge(inclExpr, currNode.expr, credWeight)
            
            elif isinstance(currNode.expr, LIExpression):
                linkingRole = SIExpression(currNode.expr.principal, currNode.expr.roleNameA)
                linkingRoleNode = proofGraph.addNode(linkingRole)
                linkingRoleNode.attachMonitor(LinkingMonitor(currNode, proofGraph, self))
            
            elif isinstance(currNode.expr, IIExpression):
                intersectedRoleA = SIExpression(currNode.expr.principalA, currNode.expr.roleNameA)
                intersectedRoleB = SIExpression(currNode.expr.principalB, currNode.expr.roleNameB)
                intersectedRoleNodeA = proofGraph.addNode(intersectedRoleA)
                intersectedRoleNodeB = proofGraph.addNode(intersectedRoleB)
                intersectionMonitor = IntersectionMonitor(currNode, proofGraph, self)
                intersectedRoleNodeA.attachMonitor(intersectionMonitor)
                intersectedRoleNodeB.attachMonitor(intersectionMonitor)

        return startingNode.solutions

    def verifyProof(self, proof, stackSize, tx={}):
        """
        Requests the execution of the on-chain verification algorithm

        :param proof: the sequence of expression identifiers that constitutes the proof
        :param stackSize: suggested size of the processing stack
        :param tx: optional parameter containing any transaction preferences
        """
        res = self.contract.functions.verifyProof(proof, stackSize).call(tx)
        return {'principal': res[0], 'rolename': Web3.to_hex(res[1]), 'member': res[2], 'weight': res[3]}
